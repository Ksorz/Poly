#include <iostream> 
#include <Windows.h>
#include <string>

using namespace std;


// Ковариантность типа возврата, сокрытие (---9---)
void _ReturnTypeCovariance_Concealment()
{
	struct House {};
	struct Dormitory : House {};

	struct Person
	{
		virtual House* liveAt() {}
		virtual string toString() const {}					// 2) Сокрытие (К данной функции не получится обратиться кроме как --Person::toString();--)
	};
	struct Student : Person
	{														// 1) Подвид полиморфизма, может возвращать иной тип данных
		virtual Dormitory* liveAt() {}						// 1) Возвращает -&- и -*- -Dormitory- должен наследовать -House-, иначе ошибка
		virtual string toString(bool bFullInfo) const {}	// 2) только --someone.toString(bool);--, --someone.toString();--: не работает
	};
}

// Преобразование классов (---9---)
void _ConvertingClasses_Cast___PTRREF()
{
	class one {};
	class two : public one {};
	class three : public two {};
	class other {};
	class otherTwo : other {};
	// 1) Переход от производного типа к базовому выполняется ---неявно--- (только для открытого наследования) (повышающее преобразование):
	two* t = new two();										// 1) (динамическая память)
	one* o = t;												// 1) (динамическая память)
	one& o2 = *t;											// 1) (динамическая память)
	one o3 = *t;											// 1) (стэковая память) Создание нового объекта (конструктор копирования) ...
															// ... с неполными данными (поскольку -t- наследник -o3-) 
	// 2) Переход от ссылки или указателя базового типа к производному требует ---явного--- приведения (понижающее преобразование) (небезопасно):
	two* t2 = (two*)o;										// 2) Мы уверены, что по адресу указателя -o- класса -one- можно получить объект класса -two-
	two& t3 = (two&)(*o);									// 2) То же самое при работе с -&-
															// 2) Если по адресу указателя -o- нельзя получить объект -two-, то будет ошибка
	// •	Для «безопасного» приведения типов в С++ вводятся операции : static_cast, dynamic_cast, const_cast, reinterpret_cast
	// •	Все операции требуют указания целевого типа (во что преобразуем) в угловых скобках
	two* t4 = static_cast<two*>(o);							// 2) (рекомендуется) -o- класса -one- преобразуем в -two-
	// •	У каждой операции есть своя специфика и ограничения
	// •	Использование cast - операций позволяет обнаружить некоторые ошибки на стадии компиляции (до запуска программы)
	// •	Тем не менее успешная компиляция cast - операций не гарантирует «безаварийное» выполнение программы; некоторые ошибки могут возникнуть при выполнении программы
	// Приведения типов в С++: const_cast
	// •	Операция const_cast позволяет «снять» ограничение константности с переменной
	// Приведение типов в С++: static_cast
	// •	Операция static_cast позволяет выполнить проверку возможности преобразования на стадии компиляции
	// •	В случае классов (структур) преобразование с static_cast возможно, если типы связаны родством (открытое наследование):
	// •	При выполнении программы уже не выполняется проверки, действительно ли преобразование возможно:
	one* o4 = new one();
	two* t5 = static_cast<two*>(o4);							// 3) Ошибка (?)

	one* o5 = new two();
	two* t6 = static_cast<two*>(o5);							// 3) Ок
	// •	Использовать static_cast можно, если по ссылке/указателю действительно содержится объект указанного типа (или производного от него)
	// Приведение типов в С++:  dynamic_cast
	// •	Проверка	возможности	преобразования	осуществляется во время выполнения программы
	// •	Как и в случае static_cast возможно преобразование между классами, связанными открытым наследованием
	// •	Во время компиляции программы проверка корректности преобразования в плане родственности типов не выполняется
	// •	В случае невозможности преобразования возвращается нулевой указатель
	one* o6 = dynamic_cast<one*>(t6);
	if (!o6)												// 4) Проверка принадлежности указателя к нужному классу
	{														// 4) В случае несоответствия -o6- будет -nullptr-
		cout << "p is not -one-" << endl;
	}
	// •	Проверка типов выполняется на основе указателя на таблицу виртуальных методов (vmtp). Таблица (и её адрес) уникальна для каждого типа. 
	// •	Поэтому динамическое преобразование с dynamic_cast возможно для классов с виртуальными методами(для полиморфных классов)
	// •	Если в базовом классе устранить виртуальность методов, то преобразование станет невозможным(в отличие от static_cast)
	one* t7 = new two();
	// --two* t8 = dynamic_cast<two*>(t7);--				// 5) Ошибка
	// •	Операция поддерживается и для ссылок; в случае невозможности преобразования генерируется исключение bad_cast
	// Система RTTI
	// •	dynamic_cast является частью механизма RTTI (run time type identification) – динамической идентификации типов
	// •	Другие средства RTTI: typeid – для идентификации типа, type_info – для получения информации о типах
	// •	RTTI работает только с иерархией классов, содержащих виртуальные методы
	// •	Операция typeid используется для проверки совпадения типов; в качестве аргумента – либо название класса, либо конкретный объект.
	one* t9 = new two();
	if (typeid(*t) == typeid(one)) cout << "Type is one" << endl;
	if (typeid(*t) == typeid(two)) cout << "Type is two" << endl;
	cout << "name of type: " << typeid(*t9).name() << endl;
	// Приведение типов в С++:  reinterpret_cast
	// •	Самая «низкоуровневая» операция приведения
	// •	Обычно используется для «интерпретации» адресов(преобразования указателей разных типов, не связанных «родством») 
	// •	Переход от void* к указателю на фактический объект :
	void* t10 = new two();
	two* t11 = reinterpret_cast<two*>(t10);
	// •	Переход между разными типами, но с совместимой внутренней структурой :
	// --Point * point1 = new Point{ 1.5, 2.4 };--
	// --Point2D* point2 = reinterpret_cast<Point2D*>(point1);--
	// --cout << "x = " << point2->x << ", y = " << point2->y << endl;--
	// •	Интерпретация числа как адреса на область динамической памяти
	long x = 0xd76e50;
	one* o7 = reinterpret_cast<one*>(x);

}

