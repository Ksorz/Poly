// Заголовочные файлы --
// iostream: классы, функции и переменные для организации ввода-вывода
#include <iostream> 
/* climits: определяет константы с ограничениями целочисленного типа данных для конкретной системы и компилятора
CHAR_BIT	Количество бит в символе типа char.	 8
SCHAR_MIN	Минимальное значение объекта типа signed char. - 128
SCHAR_MAX	Максимальное значение объекта типа signed char.	127
UCHAR_MAX	Максимальное значение объекта типа unsigned char.	255
CHAR_MIN	Минимальное значение объекта типа char. - 128
CHAR_MAX	Максимальное значение объекта типа char.	127
MB_LEN_MAX	Максимальное количество байтов многобайтового символа, любого языка.	16
SHRT_MIN	Минимальное значение объекта типа short int. - 32768
SHRT_MAX	Максимальное значение объекта типа short int.	32767
USHRT_MAX	Максимальное значение объекта типа unsigned short int.	65535
INT_MIN	Минимальное значение объекта типа int. - 32767
INT_MAX	Максимальное значение объекта типа int.	2147483647
UINT_MAX	Максимальное значение объекта типа unsigned int.	4294967295
LONG_MIN	Минимальное значение объекта типа long int. - 9223372036854775808
LONG_MAX	Максимальное значение объекта типа long int.	9223372036854775807
ULONG_MAX	Максимальное значение объекта типа unsigned long int.	18446744073709551615 */
#include <climits>
/* Windows.h является специфичным для Windows заголовочным файлом для языков программирования C и C ++, 
который содержит объявления для всех функций в API Windows, всех распространенных макросов, используемых
программистами Windows, и всех типов данных, используемых различными функциями и подсистемы */
#include <Windows.h>
// string: класс с методами и переменными для организации работы со строками в языке программирования
#include <string>

using namespace std;

void garbage()
{
	int ivalForExample = 10;               // Инициализация в стэке
	int ivalForExample2 = 10;
	// ::::::::::::::::::::::::::::::
	// ::::: ССЫЛКИ И УКАЗАТЕЛИ :::::
	// ::::::::::::::::::::::::::::::
	// Указатель инициализируем адресом переменной number
	int* p1 = &ivalForExample;
	// Можно менять значение numForEx через указатель, выполнив разыменование
	*p1 = 20;
	// Ссылочная переменная r1 (псевдоним для области памяти, инициализация обязательна)
	int& r1 = ivalForExample;
	// Можно менять значение ivalForExample через ссылочную переменную
	r1 = 30;
	// Адреса ivalForExample, p1, &r1 равны
	cout << ivalForExample << " " << p1 << " " << r1 << " " << *p1 << endl; // 30 'адрес' 30 30
	void just_read(int& value);            // lvalue
	void just_read(const int& value);
	// :::::::::::::::::::::
	// ::::: КОНСТАНТЫ :::::
	// :::::::::::::::::::::
	// Запрещаем менять значение, но не адрес указателя --
	int const* p2 = &ivalForExample;       // -- Указатель на константу (const int* p2 = &ivalForExample; -- то же самое)
	// *p2 = 40;                           // Ошибка (значение поменять нельзя)
	// p2 = &ivalForExample2;              // Ок     (но адрес указателя поменять можно)
	// Запрещаем менять адрес указателя, но не значение --
	int* const p3 = &ivalForExample;       // -- Константный указатель
	// *p3 = 40;                           // Ок     (значение поменять можно)
	// p3 = &ivalForExample2;              // Ошибка (но адрес указателя поменять нельзя)
	// Запрещаем менять адрес указателя и значение --
	int const* const p4 = &ivalForExample; // -- Константный указатель на константу
	// *p4 = 40;                           // Ошибка (значение поменять нельзя)
	// p4 = &ivalForExample2;              // Ошибка (адрес указателя поменять нельзя)
	int& const r2 = ivalForExample;        // -- То же самое, что и (int& r2 = ivalForExample; -- Ссылки всегда константы)
	int const& r3 = ivalForExample;        // -- Ссылка на константу
	// "Экономная" передача данных в функцию --
	void justReadBigValue(long long const& x);
}


// В данном случае нужно передавать адреса значений или указатели -- swap1(&x, &y);
void swap1(int* px, int* py)
{
	int t = *px;
	*px = *py;
	*py = t;
}

// В данном случае нужно передавать значения (lvalue) -- swap2(x, y);
void swap2(int& px, int& py)
{
	int t = px;
	px = py;
	py = t;
}

// Последовательное хранение строк динамического массива в памяти
int** optimizedArray(int sizeX, int sizeY)
{
	int** arr = new int* [sizeX];
	arr[0] = new int[sizeX * sizeY];       // Выделяем в одной строке память под все элементы массива
	for (size_t i = 1; i != 5; i++)        // Настраиваем указатели для получившейся строки
	{
		arr[i] = arr[i - 1] + sizeY;       // С учетом адресной арифметики прибавляется sizeY * (размер int) байт
	}
	return arr;
	// Удаление в 2 шага (эти строки не будут выполнены в данной функции) --
	delete arr[0];                         // Удаляем всю строку
	delete arr;                            // Удаляем разбивку строки
}


int main()
{
	setlocale(LC_ALL, "Russian");
	SetConsoleOutputCP(1251);
	SetConsoleCP(1251);

	garbage();

	return 0;
}