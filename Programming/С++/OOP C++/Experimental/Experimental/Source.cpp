// -- Заголовочные файлы
// iostream: классы, функции и переменные для организации ввода-вывода
#include <iostream> 
/* climits: определяет константы с ограничениями целочисленного типа данных для конкретной системы и компилятора
CHAR_BIT	Количество бит в символе типа char.	 8
SCHAR_MIN	Минимальное значение объекта типа signed char. - 128
SCHAR_MAX	Максимальное значение объекта типа signed char.	127
UCHAR_MAX	Максимальное значение объекта типа unsigned char.	255
CHAR_MIN	Минимальное значение объекта типа char. - 128
CHAR_MAX	Максимальное значение объекта типа char.	127
MB_LEN_MAX	Максимальное количество байтов многобайтового символа, любого языка.	16
SHRT_MIN	Минимальное значение объекта типа short int. - 32768
SHRT_MAX	Максимальное значение объекта типа short int.	32767
USHRT_MAX	Максимальное значение объекта типа unsigned short int.	65535
INT_MIN	    Минимальное значение объекта типа int. - 32767
INT_MAX	    Максимальное значение объекта типа int.	2147483647
UINT_MAX	Максимальное значение объекта типа unsigned int.	4294967295
LONG_MIN	Минимальное значение объекта типа long int. - 9223372036854775808
LONG_MAX	Максимальное значение объекта типа long int.	9223372036854775807
ULONG_MAX	Максимальное значение объекта типа unsigned long int.	18446744073709551615 */
#include <climits>
/* Windows.h является специфичным для Windows заголовочным файлом для языков программирования C и C ++, 
который содержит объявления для всех функций в API Windows, всех распространенных макросов, используемых
программистами Windows, и всех типов данных, используемых различными функциями и подсистемы */
#include <Windows.h>
// string: класс с методами и переменными для организации работы со строками в языке программирования
#include <string>
#include "Functions.hpp"

using namespace std;

    // ::::::::::::::::::::::::
	// ::::: ТЕСТ-ФУНКЦИЯ :::::
	// ::::::::::::::::::::::::
void test()
{
	int ival = 10;                         
	int ival2 = 10;
	// ::::::::::::::::::::::::::::::
	// ::::: ССЫЛКИ И УКАЗАТЕЛИ :::::
	// ::::::::::::::::::::::::::::::
	// Указатель инициализируем адресом переменной number
	int* p1 = &ival;
	// Можно менять значение numForEx через указатель, выполнив разыменование
	*p1 = 20;
	// Ссылочная переменная r1 (псевдоним для области памяти, инициализация обязательна)
	int& r1 = ival;
	// Можно менять значение ival через ссылочную переменную
	r1 = 30;
	// Адреса ival, p1, &r1 равны
	cout << ival << " " << p1 << " " << r1 << " " << *p1 << endl; // 30 'адрес' 30 30
	system("cls");
	void just_read(int& value);            // Ссылка должна быть Lvalue
	void just_read(const int& value);
	// :::::::::::::::::::::
	// ::::: КОНСТАНТЫ :::::
	// :::::::::::::::::::::
	// Запрещаем менять значение, но не адрес указателя --
	int const* p2 = &ival;                 // -- Указатель на константу (const int* p2 = &ival; -- то же самое)
	// *p2 = 40;                           // Ошибка (значение поменять нельзя)
	p2 = &ival2;                           // Ок     (но адрес указателя поменять можно)
	// Запрещаем менять адрес указателя, но не значение --
	int* const p3 = &ival;                 // -- Константный указатель
	*p3 = 40;                              // Ок     (значение поменять можно)
	// p3 = &ival2;                        // Ошибка (но адрес указателя поменять нельзя)
	// Запрещаем менять адрес указателя и значение --
	int const* const p4 = &ival;           // -- Константный указатель на константу
	// *p4 = 40;                           // Ошибка (значение поменять нельзя)
	// p4 = &ival2;                        // Ошибка (адрес указателя поменять нельзя)
	//int& const r2 = ival;                // -- Ошибка. То же самое, что и (int& r2 = ival;) Ссылки всегда константы)
	int const& r3 = ival;                  // -- Ссылка на константу
										   // "Экономная" передача данных в функцию -- void justReadBigValue(long long const& x);
}

	// ::::::::::::::::::
	// ::::: КЛАССЫ :::::
	// ::::::::::::::::::
	// Три кита ООП:
	// •	Инкапсуляция : все элементы, связанные с некоторой абстракцией, 
	//      определяются внутри одного типа – класса; некоторые элементы класса скрыты от внешнего использования
	//		Инкапсуляция подразумевает:
	// 		•	Выделение данных и функций работы с этими данными в одной сущности – объекте (capsula);
	//      •	Сокрытие данных и части функциональности объекта
	//          Инкапсуляция как сокрытие используется:
	//          •	Для устранения из области видимости внутренней функциональности, не представляющей интерес для внешнего пользователя
	//          •	Для предотвращения некорректного определения объекта
	//          •	Для возможности изменений в «закрытой части» без необходимости изменения кода,
	//              который работает с объектом через интерфейсную часть
	
	// •	Наследование : классы могут определяться на основе существующих базовых классов
	
	// •	Полиморфизм  : возможность работы унифицированным способом с разными типами объектов, реализующими разное поведение
	// ООП упрощает(ипоощряет) повторное использование кода, модификацию и расширение
	// существующей	функциональности, «управление зависимостями»

	// Компилятор автоматически создает специальные функции (по умолчанию):
	// •	Конструктор без параметров;
	// •	Деструктор;
	// •	Оператор копирования(x = y);
class Person						       // Классы можно определять внутри функции (но зачем?) (содержат данные и функции)
{
private:                                   // Обычно поля (данные) содержатся в private
    // ::::: ПОЛЯ :::::
	int age;
	string name;
public:
	// ::::: КОНСТРУКТОРЫ ::::::
	//Person() { name, age; }              // По умолчанию (Person somebody;) (неопределённые значения)
	// Выражения инициализации:
	Person() : name("Bot"), age(0) {}      // По умолчанию (Person somebody;) (значения по умолчанию)
	// Создание экземпляра класса с определёнными параметрами (предпочтительная запись для инициализации полей)
	Person(string name, int age) : name(name), age(age) {}
	// Вызываем другой конструктор
	Person(int age) : Person("Bot", age) {}
	// explicit запрещает: Person somebody = string("Superbot");, разрешает только: Person somebody("Superbot");
	explicit Person(string name) : name(name) {}
	// ::::: ДЕСТРУКТОРЫ :::::
	// •	Деструкторы – специальные методы, предназначены для освобождения ресурсов(памяти)
	// •	Деструктор по умолчанию вводится компилятором, если не создается явный деструктор
	// •	Как правило, деструкторы не вызываются напрямую. Вызов выполняется компилятором
	// •	Для локальных объектов, размещенных в стэковой памяти, деструкторы автоматически вызываются при выходе 
	//		из области видимости объекта(метода, функции, структурного блока, ограниченного фигурными скобочками)
	// •	Если при создании объекта выделяется динамическая память(н - р, с помощью new), 
	//		тогда в деструкторе необходимо освобождать память с помощью delete
	~Person()                              // Деструктор (удаление объекта и освобождение памяти)
	{
		cout << "[ Destructor ] " << name << ", " << age << " <" << this << ">" << endl; // this: указатель на текущий объект
	}
	// ::::: МЕТОДЫ :::::                  // Функции внутри класса называют "Методы"
									       // +++ Методы, не изменяющие объект, рекомендуется помечать const
	void getData() const
	{
		cout << "Имя: " << this->name << "\nВозраст: " << age << endl; // В данном случае this не имеет смысла, использовано как пример
	}
	const Person& getOlder(const Person& other) const
	{
		return age > other.age ? *this : other;
	}
	// В ООП рекомендуется все данные - члены класса объявлять как закрытые, тем самым запрещая напрямую обращаться к данным объекта.
	// Внешние пользователи получают опосредованный доступ к элементам объекта через открытые методы (интерфейсную часть).
	// Методы доступа к конкретным элементам также называют getter, setter
};
class Line
{
private:
	char* data;
	int size;
	// ::::: ЗАПРЕТЫ :::::
	//void operator= (Line& other) {}      // Запрет оператора приваивания (ли другого опертатора (Line& operator+ (Line& other)))
	//Line(const Line& other) {}           // Запрет копирования
public:
	Line(const char* s) : Line()
	{
		size = strlen(s);                  // Стэковая память (длина строки)
		data = new char[size];             // Динамическая память
		for (int i = 0; i < size; i++) data[i] = s[i]; // Посимвольное копирование
	}
	Line() : data(nullptr), size(0) {}     // Конструктор по умолчанию (nullptr: нулевой указатель)
	// ::::: КОНСТРУКТОР КОПИРОВАНИЯ :::::
	// •	Конструктор копирования описывает как создавать объект на основе существующего объекта
	// •	Конструктор копирования принимает один аргумент – типа ссылки на объект данного типа; часто тип аргумента снабжают модификатором const
	Line(const Line& other)                // В данном случае объекта ещё нет и мы его создаём
	{
		size = strlen(other.data);
		data = new char[size];
		for (int i = 0; i < size; i++) data[i] = other.data[i];
	}
	// ::::: ОПЕРАТОР ПРИСВАИВАНИЯ :::::
	Line& operator= (Line& other)          // В данном случае объект уже существует и мы его переопределяем
	{                                     
		// Таким образом можно переопределять многие операторы (Line& operator+ (Line& other))
	    // •    Не поддерживается перегрузка операций:
		//      –	«точка» (выборка элементов класса или структуры)
		//      –	«тернарный оператор» (a ? b : c)
		//      –	“::” (открытие области видимости)
		// •	Специфические операции : ->, [], (), (int)
		// •	Для переопределения операции используется «operator»
		// •	Операция может быть элементом класса, дружественной функцией или внешней функцией
		//      (для некоторых операций разрешено переопределение только внутри пользовательского типа)


		if (&other == this) return *this;  // Проверяем на самоприсваивание (line3 = line3;)
		delete[] data;                     // Удаляем текущий объект (устраняем возможность утечки памяти)
		size = other.size;
		data = new char[size];
		for (int i = 0; i < size; i++) data[i] = other.data[i];
		return *this;                      // Возможность формирования цепочек (line1 = line2 = line3;) (*this: текущий объект, не указатель)
	}

	char operator[] (int i) const { return (i < size) ? data[i] : 0; } // Переопределение [] (int i: число в [])

	~Line() { delete[] data; }             // Деструктор по умолчанию здесь использовать нельзя т.к. была выделена динамическая память
										   // Т.к. new char[] то и delete[] (квадратные скобки)
	int getSize() const { return size; }
	const char* c_str() { return data; }
};

class Point
{
public:
	Point() { x = 0, y = 0; }              // Конструктор с параметрами по умолчанию
	Point(double x, double y) : x(x), y(y) {} // Конструктор с параметрами

	double operator[] (bool b) const { return b ? x : y; } // Переопределение [] с аргументом типа bool (const как часть имени метода)
	double& operator[] (bool b) { return b ? x : y; } // Перегрузка переопределений (& для возможности изменения полей)

	Point& operator++()                    // Prefix increment. Без аргументов (++x)
	{
		++x; ++y;                          // Нет копирования
		return *this;
	}
	Point operator++(int i)                // Postfix increment. С аргументом (x++) (i: не используется)
	{
		Point temp(*this);                 // Временный объект, копирование
		++(*this);                         // Обращение к предыдущему переопределению (prefix increment)
		return temp;
	}
	                                       // friend: внешняя функция или класс, которым доступны внутренние элементы класса
	friend std::ostream& operator<< (std::ostream& os, const Point& p) // 1й аргумент (cout) - не объект класса, поэтому функция должна быть внешней
		                                   // Функция не обязательно должна быть friend, только если нужен доступ к закрытым полям
		                                   // В данном случае это внешняя дружественная функция внутри класса, но она не является элементом класса
	{                                      // Полное определение такой функции можно поместить кв класс
		os << p.x << ", " << p.y; 
		return os;
	}

	double x, y;
};

class Segment
{
private:
	Point a, b;
public:
	Segment() : a(3.14, 2.78), b(2.78, 3.14) {}
};












    // ===========================================================================================================================
	// =========================================================  MAIN  ==========================================================
	// ===========================================================================================================================
int main()
{
	setlocale(LC_ALL, "Russian");
	SetConsoleOutputCP(1251);
	SetConsoleCP(1251);

	test();
	{									   // -- Локальная область видимости, вне пределов {} a, b будут недоступны
		Point a;                           // Инициализация (empty object)
		a = Point { 3.14, 2.78 };          // Присвоение (создает и присваивает временный объект)
		Point b { 2.78, 3.14 };            // +++ Инициализация без копирования (нет временного объекта) (улучшает быстродействие)
		// ----------------------- Дополнить классом (лек 4 1:30) -------------------------
	}									   // -- Локальная область видимости, вне пределов {} a, b будут недоступны
	// ===========================================================================================================================
	// =======================================================  СТРУКТУРЫ  =======================================================
	// ===========================================================================================================================
	Point point{ 3.14, 2.71 };             // Point point = { 3.14, 2.71 }; (то же самое)
	Point* ptrPoint = &point;              // Указатель на структуру (Point ptrPoint = new Point;)
	Point& refPoint = point;               // Ссылка на структуру
	ptrPoint->x = 3.1415;                  // Селектор выбора ('->' при работе с указателями)
	refPoint.y = 2.7182;
	// cout << point.x << " " << point.y << endl; // 3.1415 2.7182
	// ===========================================================================================================================
	// ========================================================  КЛАССЫ  =========================================================
	// ===========================================================================================================================
	Person other = Person("Bob", 23);      // Явная форма вызова конструктора
	Person man("John", 17);                // Неявная форма вызова конструктора
	Person* lady = new Person("Ann", 17);  // Вызов конструктора при динамическом создании объекта
	Person somebody;                       // Конструктор по умолчанию
	// "Списковая инициализация"
	Person person1{ "Peter", 11 };
	const Person person2 = { "Nick", 12 }; // При работе с const объектом можно обращаться только к const методам
	Person person3{};                      // Использует конструктор по умолчанию

	// •	Копирование данных осуществляется при инициализации, присваивании, передаче параметров и возврате из функции
	// •	Для пользовательских типов(классов\структур) для корректного выполнения копирования внутренних элементов 
	//      объектов необходимо переопределить конструктор копирования и операцию присваивания
	// •	Компилятор автоматически создаёт конструктор копирования и операцию присваивания, реализуя «побитовое» копирование внутренних элементов

	Line line1("Hello world");
	Line line3("Hasta la vista");
	                                       // Ошибка если конструктор присваивания по умолчанию!
	Line line2 = line1;                    // Конструктор копирования (по умолчанию: побитовое копирование)
	                                       // Передача в функцию ((Show(line1);): тоже конструктор копирования
	line3 = line2 = line1;                 // Операция присваивания (по умолчанию: побитовое копирование)
	                                       // Побитовое копирование корректно работает только с объектами в стэковой памяти
	cout << Line("all that glitters is gold").c_str() << endl; // Анонимный (временный) объект


	cout << point << endl;


	int** arr = optimizedArray(5, 7);


	return 0;
}