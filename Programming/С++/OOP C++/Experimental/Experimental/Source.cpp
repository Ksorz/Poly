// -- Заголовочные файлы
// iostream: классы, функции и переменные для организации ввода-вывода
#include <iostream> 
/* climits: определяет константы с ограничениями целочисленного типа данных для конкретной системы и компилятора
CHAR_BIT	Количество бит в символе типа char.	 8
SCHAR_MIN	Минимальное значение объекта типа signed char. - 128
SCHAR_MAX	Максимальное значение объекта типа signed char.	127
UCHAR_MAX	Максимальное значение объекта типа unsigned char.	255
CHAR_MIN	Минимальное значение объекта типа char. - 128
CHAR_MAX	Максимальное значение объекта типа char.	127
MB_LEN_MAX	Максимальное количество байтов многобайтового символа, любого языка.	16
SHRT_MIN	Минимальное значение объекта типа short int. - 32768
SHRT_MAX	Максимальное значение объекта типа short int.	32767
USHRT_MAX	Максимальное значение объекта типа unsigned short int.	65535
INT_MIN	    Минимальное значение объекта типа int. - 32767
INT_MAX	    Максимальное значение объекта типа int.	2147483647
UINT_MAX	Максимальное значение объекта типа unsigned int.	4294967295
LONG_MIN	Минимальное значение объекта типа long int. - 9223372036854775808
LONG_MAX	Максимальное значение объекта типа long int.	9223372036854775807
ULONG_MAX	Максимальное значение объекта типа unsigned long int.	18446744073709551615 */
#include <climits>
/* Windows.h является специфичным для Windows заголовочным файлом для языков программирования C и C ++, 
который содержит объявления для всех функций в API Windows, всех распространенных макросов, используемых
программистами Windows, и всех типов данных, используемых различными функциями и подсистемы */
#include <Windows.h>
// string: класс с методами и переменными для организации работы со строками в языке программирования
#include <string>
#include "Functions.hpp"

using namespace std;

// :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
// ::::::::::::::::::::::::::::::::::::::::::::::::::  ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ  ::::::::::::::::::::::::::::::::::::::::::::::::::::
// :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
// •	Переменные, которые объявляются за рамками структурного блока функции, являются глобальными(внешними)
// •	Глобальные переменные доступны во всей программе, т.е.во всех модулях
//      (файлах с кодом* .cpp), в которых введены их имена(объявлены)
// •	Переменные на разных уровнях иерархии могут иметь одинаковые имена(перекрываться)
// •	Для обращения к глобальной переменной (в случае неоднозначности) можно использовать символ ::
// •	Для работы с глобальной переменной в разных модулях необходимо ввести объявление в каждом модуле с использованием extern (пример в Functions.cpp)
int globalVar = 10;                        // Глобальная переменная
int fGlobalVar()
{
	static int inFuncStaticCounter = 0;    // •		Если переменная объявляется внутри функции с ключевым словом static, 
										   //       то в этом случае она является глобальной в плане времени существования, но доступна только внутри функции.
										   // • 	Время жизни такой переменной – от первого вызова функции, когда происходит инициализация, до конца работы приложения.
	globalVar += 10;
	return ++inFuncStaticCounter;
}
static int sGlobalVar = 100;               // Статическая глобальная переменная – доступна только в пределах модуля (внутренняя переменная)
										   // Модуль компиляции ( = единица трансляции) – файл с программным кодом (*.cpp) с учётом подключаемых файлов(*.h)
// :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
// :::::::::::::::::::::::::::::::::::::::::::::::::::::::  ТЕСТ-ФУНКЦИЯ  ::::::::::::::::::::::::::::::::::::::::::::::::::::::::
// :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
void test()
{
	int ival = 10;                         
	int ival2 = 10;
	// :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	// ::::::::::::::::::::::::::::::::::::::::::::::::::  ССЫЛКИ И УКАЗАТЕЛИ  :::::::::::::::::::::::::::::::::::::::::::::::::::
	// :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	// Указатель инициализируем адресом переменной number
	int* p1 = &ival;
	// Можно менять значение numForEx через указатель, выполнив разыменование
	*p1 = 20;
	// Ссылочная переменная r1 (псевдоним для области памяти, инициализация обязательна)
	int& r1 = ival;
	// Можно менять значение ival через ссылочную переменную
	r1 = 30;
	// Адреса ival, p1, &r1 равны
	cout << ival << " " << p1 << " " << r1 << " " << *p1 << endl; // 30 'адрес' 30 30
	system("cls");
	void just_read(int& value);            // Ссылка должна быть Lvalue
	void just_read(const int& value);
	// :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	// :::::::::::::::::::::::::::::::::::::::::::::::::::::::  КОНСТАНТЫ  :::::::::::::::::::::::::::::::::::::::::::::::::::::::
	// :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	// Запрещаем менять значение, но не адрес указателя --
	int const* p2 = &ival;                 // -- Указатель на константу (const int* p2 = &ival; -- то же самое)
	// *p2 = 40;                           // Ошибка (значение поменять нельзя)
	p2 = &ival2;                           // Ок     (но адрес указателя поменять можно)
	// Запрещаем менять адрес указателя, но не значение --
	int* const p3 = &ival;                 // -- Константный указатель
	*p3 = 40;                              // Ок     (значение поменять можно)
	// p3 = &ival2;                        // Ошибка (но адрес указателя поменять нельзя)
	// Запрещаем менять адрес указателя и значение --
	int const* const p4 = &ival;           // -- Константный указатель на константу
	// *p4 = 40;                           // Ошибка (значение поменять нельзя)
	// p4 = &ival2;                        // Ошибка (адрес указателя поменять нельзя)
	//int& const r2 = ival;                // -- Ошибка. То же самое, что и (int& r2 = ival;) Ссылки всегда константы)
	int const& r3 = ival;                  // -- Ссылка на константу
										   // "Экономная" передача данных в функцию -- void justReadBigValue(long long const& x);
}

	// :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	// ::::::::::::::::::::::::::::::::::::::::::::::::  КЛАССЫ {инкапсуляция}  ::::::::::::::::::::::::::::::::::::::::::::::::::
	// :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	// Три кита ООП:
	// •	Инкапсуляция : все элементы, связанные с некоторой абстракцией, 
	//      определяются внутри одного типа – класса; некоторые элементы класса скрыты от внешнего использования
	//		Инкапсуляция подразумевает:
	// 		•	Выделение данных и функций работы с этими данными в одной сущности – объекте (capsula);
	//      •	Сокрытие данных и части функциональности объекта
	//          Инкапсуляция как сокрытие используется:
	//          •	Для устранения из области видимости внутренней функциональности, не представляющей интерес для внешнего пользователя
	//          •	Для предотвращения некорректного определения объекта
	//          •	Для возможности изменений в «закрытой части» без необходимости изменения кода,
	//              который работает с объектом через интерфейсную часть
	// •	Наследование : классы могут определяться на основе существующих базовых классов
	// •	Полиморфизм  : возможность работы унифицированным способом с разными типами объектов, реализующими разное поведение
	// ООП упрощает(ипоощряет) повторное использование кода, модификацию и расширение
	// существующей	функциональности, «управление зависимостями»
	// Компилятор автоматически создает специальные функции (по умолчанию):
	// •	Конструктор без параметров;
	// •	Деструктор;
	// •	Оператор копирования(x = y);
class Person						       // Классы можно определять внутри функции (но зачем?) (содержат данные и функции)
{
private:                                   // Обычно поля (данные) содержатся в private

    // :::::::::::::::::::::::::::::::::::::::::::::::::::::::::  ПОЛЯ  ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	int age;
	string name;
public:

	// ::::::::::::::::::::::::::::::::::::::::::::::  КОНСТРУКТОРЫ И ДЕСТРУКТОРЫ  :::::::::::::::::::::::::::::::::::::::::::::::

	//Person() { name, age; }              // По умолчанию (Person somebody;) (неопределённые значения)
	// Выражения инициализации:
	Person() : name("Bot"), age(0) {}      // По умолчанию (Person somebody;) (значения по умолчанию)
	// Создание экземпляра класса с определёнными параметрами (предпочтительная запись для инициализации полей)
	Person(string name, int age) : name(name), age(age) {}
	// Вызываем другой конструктор
	Person(int age) : Person("Bot", age) {}
	// explicit запрещает: Person somebody = string("Superbot");, разрешает только: Person somebody("Superbot");
	explicit Person(string name) : name(name) {}
	// ::::: ДЕСТРУКТОРЫ :::::
	// •	Деструкторы – специальные методы, предназначены для освобождения ресурсов(памяти)
	// •	Деструктор по умолчанию вводится компилятором, если не создается явный деструктор
	// •	Как правило, деструкторы не вызываются напрямую. Вызов выполняется компилятором
	// •	Для локальных объектов, размещенных в стэковой памяти, деструкторы автоматически вызываются при выходе 
	//		из области видимости объекта(метода, функции, структурного блока, ограниченного фигурными скобочками)
	// •	Если при создании объекта выделяется динамическая память(н - р, с помощью new), 
	//		тогда в деструкторе необходимо освобождать память с помощью delete
	~Person()                              // Деструктор (удаление объекта и освобождение памяти)
	{
		//cout << "[ Destructor ] " << name << ", " << age << " <" << this << ">" << endl; // this: указатель на текущий объект
	}

	// ::::::::::::::::::::::::::::::::::::::::::::::::::::::::  МЕТОДЫ  :::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	                                       // Функции внутри класса называют "Методы"
									       // +++ Методы, не изменяющие объект, рекомендуется помечать const
	void getData() const
	{
		cout << "Имя: " << this->name << "\nВозраст: " << age << endl; // В данном случае this не имеет смысла, использовано как пример
	}
	const Person& getOlder(const Person& other) const
	{
		return age > other.age ? *this : other;
	}
	// В ООП рекомендуется все данные - члены класса объявлять как закрытые, тем самым запрещая напрямую обращаться к данным объекта.
	// Внешние пользователи получают опосредованный доступ к элементам объекта через открытые методы (интерфейсную часть).
	// Методы доступа к конкретным элементам также называют getter, setter
};

class Line
{
private:
	char* data;
	int size;

	// :::::::::::::::::::::::::::::::::::::::::::::::::::::::  ЗАПРЕТЫ  :::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	//void operator= (Line& other) {}      // Запрет оператора приваивания (ли другого опертатора (Line& operator+ (Line& other)))
	//Line(const Line& other) {}           // Запрет копирования
public:
	Line(const char* s) : Line()
	{
		size = strlen(s);                  // Стэковая память (длина строки)
		data = new char[size];             // Динамическая память
		for (int i = 0; i < size; i++) data[i] = s[i]; // Посимвольное копирование
	}
	Line() : data(nullptr), size(0) {}     // Конструктор по умолчанию (nullptr: нулевой указатель)

	// :::::::::::::::::::::::::::::::::::::::::::::::::: КОНСТРУКТОР КОПИРОВАНИЯ :::::::::::::::::::::::::::::::::::::::::::::::::

	// •	Конструктор копирования описывает как создавать объект на основе существующего объекта
	// •	Конструктор копирования принимает один аргумент – типа ссылки на объект данного типа; часто тип аргумента снабжают модификатором const
	Line(const Line& other)                // В данном случае объекта ещё нет и мы его создаём
	{
		size = strlen(other.data);
		data = new char[size];
		for (int i = 0; i < size; i++) data[i] = other.data[i];
	}

	// ::::::::::::::::::::::::::::::::::::::::::::::::::::: ПЕРЕОПРЕДЕЛЕНИЕ ::::::::::::::::::::::::::::::::::::::::::::::::::::::

	Line& operator= (Line& other)          // В данном случае объект уже существует и мы его переопределяем
	{                                     
		// Таким образом можно переопределять многие операторы (Line& operator+ (Line& other))
	    // •    Не поддерживается перегрузка операций:
		//      –	«точка» (выборка элементов класса или структуры)
		//      –	«тернарный оператор» (a ? b : c)
		//      –	“::” (открытие области видимости)
		// •	Специфические операции : ->, [], (), (int)
		// •	Для переопределения операции используется «operator»
		// •	Операция может быть элементом класса, дружественной функцией или внешней функцией
		//      (для некоторых операций разрешено переопределение только внутри пользовательского типа)


		if (&other == this) return *this;  // Проверяем на самоприсваивание (line3 = line3;)
		delete[] data;                     // Удаляем текущий объект (устраняем возможность утечки памяти)
		size = other.size;
		data = new char[size];
		for (int i = 0; i < size; i++) data[i] = other.data[i];
		return *this;                      // Возможность формирования цепочек (line1 = line2 = line3;) (*this: текущий объект, не указатель)
	}

	char operator[] (int i) const { return (i < size) ? data[i] : 0; } // Переопределение [] (int i: число в [])

	~Line() { delete[] data; }             // Деструктор по умолчанию здесь использовать нельзя т.к. была выделена динамическая память
										   // Т.к. new char[] то и delete[] (квадратные скобки)
	int getSize() const { return size; }
	const char* c_str() { return data; }
};

class Point
{
public:
	double x, y;
	Point() { x = 0, y = 0; }              // Конструктор с параметрами по умолчанию
	Point(double x, double y) : x(x), y(y) {} // Конструктор с параметрами

	double operator[] (bool b) const { return b ? x : y; } // Переопределение [] с аргументом типа bool (const как часть имени метода)
	double& operator[] (bool b) { return b ? x : y; } // Перегрузка переопределений (& для возможности изменения полей)

	Point& operator++()                    // Prefix increment. Без аргументов (++x)
	{
		++x; ++y;                          // Нет копирования
		return *this;
	}
	Point operator++(int i)                // Postfix increment. С аргументом (x++) (i: не используется)
	{
		Point temp(*this);                 // Временный объект, копирование
		++(*this);                         // Обращение к предыдущему переопределению (prefix increment)
		return temp;
	}
	                                       // friend: внешняя функция или класс, которым доступны внутренние элементы класса
	friend std::ostream& operator<< (std::ostream& os, const Point& p) // 1й аргумент (cout) - не объект класса, поэтому функция должна быть внешней
		                                   // Функция не обязательно должна быть friend, только если нужен доступ к закрытым полям
		                                   // В данном случае это внешняя дружественная функция внутри класса, но она не является элементом класса
	{                                      // Полное определение такой функции можно поместить кв класс
		os << p.x << ", " << p.y; 
		return os;
	}
};

class Segment
{
private:
	Point a, b;
public:
	Segment() : a(3.14, 2.78), b(2.78, 3.14) {}
};

	// :::::::::::::::::::::::::::::::::::::::::::::::::::: СТАТИЧЕСКИЕ ПОЛЯ ::::::::::::::::::::::::::::::::::::::::::::::::::::::

	// •	Статические элементы не связаны с конкретным экземпляром класса
	// •	В смысловом плане статические элементы принадлежат «классу как таковому», а не конкретным объектам.
	// •	Статические поля – глобальные переменные, область видимости ограничена рамками класса
	// •	Время жизни статических полей совпадает с временем жизни программы
	// •	Доступ извне к статическому полю возможен с использованием имени класса с учетом модификаторов доступа

class RFraction
{
	int num, den;
	static int counter;                    // Счетчик количества экземпляров класса
public:
	RFraction(int n, int d) : num(n), den(d) { counter++; }
	~RFraction() { counter--; }
	static int getCounter() { return counter; } // Статические методы доступны без создания экземпляра класса
	static RFraction Unity;
	static RFraction Zero;
};
int RFraction::counter = 0;
RFraction RFraction::Unity = RFraction(1, 1);
RFraction RFraction::Zero = RFraction(0, 1);

    // :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    // ::::::::::::::::::::::::::::::::::::::::::  КЛАССЫ {наследование, полиморфизм}  :::::::::::::::::::::::::::::::::::::::::::
    // :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    // •	Наследование – один важнейших принципов (возможностей) ООП
    // •	Наследование позволяет удобным образом вводить новые типы на базе существующих, расширяя их описание и функциональность
    // •	Наследование – это переход от общего к частному, уточнение описания объекта
    // •	Наследование неразрывно связано с полиморфизмом и возможностью унифицированной работы со всей иерархией объектов
    // •	С точки зрения расположения данных в памяти наследование это добавление новых полей данных к ранее описанной структуре (классу)
    // 
    // •	Класс Animal – базовый (родительский)
class Animal
{
	int weigth;
	int legs;
	bool fur;
public:
	Animal(int w, int l, bool f) : weigth(w), legs(l), fur(f) {}
	virtual ~Animal() {}                   // В случае классов с виртуальными функциями рекомендуется вводить виртуальный деструктор
	virtual void SayHello() const { cout << "Some Roar"; } // virtuel: Возможность динамиеского полиморфизма
	                                       // Функция roar (через полиморфизм адреса) обратится к SayHello из производного класса
};
    // •	Класс Dog, Cat – производные (потомки)
class Dog : public Animal
{
	bool goodBoy;
	string roar;
public:
	Dog(bool gb = true, string r = "Rrrr") : Animal(10, 4, true), goodBoy(gb), roar(r) {}
	void SayHello() const { cout << roar; }
};

class Cat : public Animal
{
	bool fatCat;
	string roar;
public:
	Cat(bool fc = true, string r = "Meow") : Animal(10, 4, true), fatCat(fc), roar(r) {}
	void SayHello() const { cout << roar; }
};
void roar(Animal* a) { a->SayHello(); }

    // •	В С++ различаются типы наследования : открытое наследование(public) и закрытое наследование(private)
    // •	Модель защиты указывается в заголовке класса рядом с базовым классом :
class A {};
class B : public A {};                     // Чаще всего так
class C : private A {};
    // •	Открытое наследование : все открытые элементы, объявленные в классе A, будут доступны и для объектов класса B
    // •	Закрытое наследование : все открытые элементы класса A в классе С становятся закрытыми, т.е.доступны только внутри класса С;
    //      информация о наследовании класса C от класса A не доступна(неявное преобразование от С к A не выполняется)
    // •	По умолчанию : для структур реализуется открытое наследование, для классов - закрытое

class Base
{
private:
	int x, y;
	void setX(int xx) { x = xx; }          // private: Изменение x ограничено (в т.ч. для наследников)
protected:                                 // Модификатор доступа protected позволяет ввести элементы, которые доступны в рамках класса и производных типах
	void setY(int yy) { y = yy; }          // protected: Изменение y ограничено (но не для наследников)
public:
	Base(int xx, int yy) : x(xx), y(yy) {}
	int getX() { return x; } int getY() { return y; }
};
class Derived : public Base
{
	int z;
public:
	Derived();
	void Update(int xx, int yy)
	{
		//setX(xx);                        // Ошибка, Производный класс не имеет доступа к закрытым элементам базового класса (не является дружественным)
 		setY(yy);
	}
	void Get(int& xx, int& yy)
	{
		xx = getX();
		yy = getY();
	}
};
    // Конструирование и деструкция «наследника»:
    // •	Объект производного типа содержит в себе элементы базового типа(некоторые из них могут быть непосредственно недоступны «наследнику»)
    // •	При создании объекта производного типа должен отработать и конструктор базового типа(раньше)
    // •	При уничтожении объекта производного типа должен отработать и деструктор базового типа(позже)
    // •	В случае уничтожения : компилятор автоматически добавляет в код деструктора производного класса(в самый его конец) вызов деструктора базового класса
    // •	В случае создания : компилятор может автоматически вызвать конструктор без параметров(по умолчанию) базового класса перед кодом конструктора производного класса
	// •	В случае создания может возникнуть необходимость в вызове определенного конструктора;
	//      можно явно обращаться к конструктору базового класса перед кодом конструктора производного класса
Derived::Derived() : Base(2, 4), z(5) {}   // Конструктор Derived
    // Таблица виртуальных методов:
    // •	При обработке обычных (невиртуальных) методов компилятор определяет адрес функции и подставляет его в точку вызова (на стадии компиляции)
    // •	Если в классе определяется хотя бы одна виртуальная функция, то компилятор вводит скрытое - поле vmtp(указатель на таблицу виртуальных методов).
    //      В таблице хранятся адреса описанных в классе виртуальных функций.
    // Виртуальные функции:
    // •	В С++ можно объявить виртуальным любой метод, кроме конструкторов и статических методов
    // •	Рекомендуется не использовать (= не вызывать) виртуальные функции в конструкторе и деструкторе
    // Абстрактные классы и функции:  
    // •	Абстрактный класс предназначен исключительно для наследования (и полиморфизма); 
    // •	Если производный класс не предоставляет реализацию для всех чисто виртуальных функций, то он тоже является абстрактным
class Figure                               // Абстрактный класс (если есть хотя бы 1 виртуальная функция, создавать экземпляры абстрактного класса нельзя)
{
	Point* points;                         // Могут содержать поля
	int nPoints;
public:
	virtual double Volume() = 0;           // Чистые виртуальные функции ( = 0 ) 
	virtual double Length() = 0;           // Классы наследники предоставят свои собственные реализации
	virtual void setPoints(Point* points, int size);
	virtual Point* getPoints();
};
    // Закрытые деструкторы:
	// •	Конструкторы и деструкторы можно объявлять как закрытые и защищенные.
	// •	Закрытый конструктор запрещает явное создание экземпляров; обеспечить возможность получения(создания) объектов можно через открытый метод класса(как правило, статический)
	// •	Закрытый деструктор исключает возможность введения переменныхобъектов, размещаемых в стэке(локальные переменные) или в статической памяти(глобальные переменные).
	// •	Объекты такого класса можно размещать исключительно в динамической памяти, так как это позволяет «обойтись» без обращения к деструктору
	// •	Освобождение памяти в этом случае можно выполнять в отдельном методе, который явно вызывается
	// •	Закрытый деструктор исключает возможность наследования
	// •	Защищенный деструктор разрешает наследование, но как и закрытый деструктор, разрешает хранение объектов только в динамической памяти.
    // Сокрытие и раскрытие:
    // •	В	производном	классе	можно	вводить	одноименные	элементы	по отношению к элементам базового класса;
    // •	Может различаться и тип элемента, и уровень доступа к элементу

class Parent
{
private: int x;
public:
	void Do() { int d = 1; };
	void f(int x) {};
};
class Child : public Parent
{
	void Do() { int d = 1; };
public:
	double x;
	int f(int x, int y) {};
};













    // ===========================================================================================================================
	// =========================================================  MAIN  ==========================================================
	// ===========================================================================================================================
int main()
{
	setlocale(LC_ALL, "Russian");
	SetConsoleOutputCP(1251);
	SetConsoleCP(1251);

	test();
	{									   // -- Локальная область видимости, вне пределов {} a, b будут недоступны
		Point a;                           // Инициализация (empty object)
		a = Point { 3.14, 2.78 };          // Присвоение (создает и присваивает временный объект)
		Point b { 2.78, 3.14 };            // +++ Инициализация без копирования (нет временного объекта) (улучшает быстродействие)
		// ----------------------- Дополнить классом (лек 4 1:30) -------------------------
	}									   // -- Локальная область видимости, вне пределов {} a, b будут недоступны
	// ===========================================================================================================================
	// =================================================  ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ  =================================================
	// ===========================================================================================================================
	float globalVar = 0.0f;                // Это локальная переменная, одноимённая глобальной
	fGlobalVar();
	int res = ::globalVar + 1;             // Для доступа к глобальной переменной используем ::
	// ===========================================================================================================================
	// =======================================================  СТРУКТУРЫ  =======================================================
	// ===========================================================================================================================
	Point point{ 3.14, 2.71 };             // Point point = { 3.14, 2.71 }; (то же самое)
	Point* ptrPoint = &point;              // Указатель на структуру (Point ptrPoint = new Point;)
	Point& refPoint = point;               // Ссылка на структуру
	ptrPoint->x = 3.1415;                  // Селектор выбора ('->' при работе с указателями)
	refPoint.y = 2.7182;
	// cout << point.x << " " << point.y << endl; // 3.1415 2.7182
	// ===========================================================================================================================
	// ================================================  КЛАССЫ {инкапсуляция}  ==================================================
	// ===========================================================================================================================
	Person other = Person("Bob", 23);      // Явная форма вызова конструктора
	Person man("John", 17);                // Неявная форма вызова конструктора
	Person* lady = new Person("Ann", 17);  // Вызов конструктора при динамическом создании объекта
	Person somebody;                       // Конструктор по умолчанию
	// "Списковая инициализация"
	Person person1{ "Peter", 11 };
	const Person person2 = { "Nick", 12 }; // При работе с const объектом можно обращаться только к const методам
	Person person3{};                      // Использует конструктор по умолчанию

	// •	Копирование данных осуществляется при инициализации, присваивании, передаче параметров и возврате из функции
	// •	Для пользовательских типов(классов\структур) для корректного выполнения копирования внутренних элементов 
	//      объектов необходимо переопределить конструктор копирования и операцию присваивания
	// •	Компилятор автоматически создаёт конструктор копирования и операцию присваивания, реализуя «побитовое» копирование внутренних элементов

	Line line1("Hello world");
	Line line3("Hasta la vista");
	                                       // Ошибка если конструктор присваивания по умолчанию!
	Line line2 = line1;                    // Конструктор копирования (по умолчанию: побитовое копирование)
	                                       // Передача в функцию ((Show(line1);): тоже конструктор копирования
	line3 = line2 = line1;                 // Операция присваивания (по умолчанию: побитовое копирование)
	                                       // Побитовое копирование корректно работает только с объектами в стэковой памяти
	cout << Line("all that glitters is gold").c_str() << endl; // Анонимный (временный) объект               -- тут какая-то ошибка

	cout << "Static counter == " << RFraction::getCounter() << endl; // Обращение к статическому полю

	// ===========================================================================================================================
	// =========================================  КЛАССЫ {наследование, полиморфизм}  ============================================
	// ===========================================================================================================================
	{
		Dog bobik;
		Animal a = bobik;                  // Вызывается конструктор копирования для Animal (отсчечение информации о Dog)
		Animal* ptr = &bobik;              // Разрешено неявное преобразование адреса переменной производного типа в адрес объекта родительского типа
		Animal& ptr_ref = bobik;           // Возможность неявного преобразования можно использовать при вызове функции. Такое преобразование называют полиморфизмом адресов
		Cat* tom = new Cat("Tom");
		roar(tom);
		delete tom;
		Child ch;
		ch.x = 3.14f;
		//ch.Do();                         // Сокрытие. Ошибка. В этом случае происходит сокрытие элементов базового класса
		                                   // В С++ поддерживается возможность обратиться к скрытому элементу через область видимости	(имя базового класса)
		ch.Parent::Do();                   // Раскрытие (Do() - private в Child, public в Parent)
		//ch.f(13);                        // Сокрытие
		ch.Parent::f(13);                  // Раскрытие
	}
	system("cls");
	_ConvertingClasses_Cast___PTRREF();



	return 0;
}

// Правило одного определения one - definition - rule(ODR):
// •	В пределах любой единицы трансляции сущности (функция, тип данных, объект) не могут иметь более одного определения
// •	В пределах программы глобальные переменные(внешние) и неподставляемые функции (не inline) не могут иметь больше одного определения
// •	Классы и подставляемые функции (т.е.сущности, у которых определение полностью или частично совмещается с объявлением) 
//      могут определяться в более чем одной единице трансляции, но определения обязаны совпадать
// •	Определения сущностей, не являющихся внешними, в разных единицах трансляции определяют различные сущности,
//      даже если их имена и типы совпадают. Эти определения беспрепятственно могут различаться.
