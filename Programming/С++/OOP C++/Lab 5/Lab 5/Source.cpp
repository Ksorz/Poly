#include <iostream> 
#include <Windows.h>
#include <string>

#include "Instrument.hpp"

using namespace std;

/*
Лабораторная работа №5. Наследование и полиморфизм

Реализовать иерархию классов для выбранного базового типа.
В качестве базового класса можно использовать вариант из таблицы, либо предложить свой собственный базовый класс и иерархию наследников(но отсутствующие в таблице).
Вариант для таблицы вычисляем по формуле : V = (int(c1) + int(c2)) % 8, где с1 и c2 – вторая буква в фамилии и имени на английском языке в верхнем регистре.

Вариант 3: Instrument

Задачи:
-- Помимо базового класса реализовать не менее 5 производных классов и, по крайней мере, 3 уровня в иерархии(н - р, класс С наследует B, а класс B наследует A).
-- В каждом классе ввести закрытые поля и открытые методы доступа к полям.
-- В базовом классе ввести виртуальные методы (н - р, toString, show), в производных классах ввести переопределения виртуальных методов.
-- Ввести статические элементы хотя бы в 3 классах (н - р, статическое поле - наибольший вес млекопитающего животного Mammal::MaximalWeight,
   статическая функция получения квадрата с заданной длиной стороны Square::GetSquare).
--- В главном модуле(с функцией main) ввести массив указателей на объекты базового класса. Число элементов массива можно задать константой(N >= 10)
--- или определять динамически в программе. Заполнить массив объектами разных типов. Выполнить обработку массива объектов для того, чтобы:
 -- подсчитать количество объектов каждого типа; для проверки типа объекта в массиве можно использовать операторы dynamic_cast или typeid;
 -- вывести информацию по каждому объекту, используя виртуальные методы базового класса(н - р, show или toString);
 -- найти объекты удовлетворяющие условию; например, найти студентов с самым ранним годом поступления (для варианта 0),
   найти четырехугольник с максимальной площадью(для варианта 4), найти млекопитающее животное с наибольшей длиной тела(для варианта 1), 
   найти самолёты с наибольшей максимальной скоростью(для варианта 6).
-- Предусмотреть освобождение динамической памяти.
*/





/*
class A
{
	static int q;
public:
	A(int qq) { setQ(qq); }

	virtual void setQ(int qq) { q = qq; }

	virtual int getQ() { return q; }
};

class B : public A
{
	int q;
public:

	B(int qq) : q(qq), A(qq) {}

	virtual void setQ(int qq) { q += qq; }

	virtual int getQ() { return q; }
};
/*
class C : public B
{
	int q;
public:
	C(int qq) : q(q) { B::setQ(qq); }
	int getQ() { return q; }
};
*/


int main()
{
	setlocale(LC_ALL, "Russian");
	SetConsoleOutputCP(1251);
	SetConsoleCP(1251);
	cout << "Вариант: " << (int('E') + int('N')) % 8 << endl;


	//B one(7);
	//B two{ 4 };

	//cout << "Cone q == " << one.getQ() << endl;
	//cout << "Cone q == " << one.B::getQ() << endl;
	//cout << "Cone q == " << one.A::getQ() << endl;



	return 0;
}